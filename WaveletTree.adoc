
== Oriented binary tree

//LeftChild Layout.Rank1(i - 1)*2 + 1
//Parrent Layout.Select1 ((i + 1)/2) - 1
//IsLChild i & 1 != 0

Succinct data structures свежее веяние в алгоритмистике. В русскоязычной школе материала мало, нет даже устоявшегося перевода. Будем восполнять этот пробел. На правах первопроходцев терминологию будем вводить налету. Пусть, скажем, компактные структуры данных. На хабре уже появилась хорошая ознакомительная статья  https://habr.com/ru/company/mailru/blog/479822/ Под катом развитие темы с описанием пары новых(такое вы не найдете у Кнута) структур, примеры применения и реализация на языке Go.

== Итак - вейвлет дерево
Поиск в Яндекс подскажет вам вейвлет преобразование, как альтернативу преобразованию Фурье в цифровой обработке сигнала с разложением на высоко и низкочастотные составляющие, что позволяет отбросить высокочастотную и осуществить сжатие с предсказуемыми потерями. Сегодня не об этом. Вейвлет деревья были предложены Grossi, Gupta, Vitter в 2003 как компактное представление последовательности на конечном алфавите с гарантированно быстрыми методами доступа.

На картинке бинарное дерево последовательности S = “ alabar a la alabarda ” на алфавите Σ = { ‘ ’ , a , b , d , l , r } Корень дерева хранит битовую карту всей последовательности, а ветви рекурсивно разбивают вхождения элементов последовательности в подразделы алфавита. Листья дерева ссылаются на символы алфавита. Так "b" последовательности кодируется 0 в корне потому что относится к левому подразделу алфавита и далее 1 в левой ветви потому что относится к правому подразделу левого раздела. На каждой ступени дерева кодируем символ 0 или 1 если он попадает в левый или правый раздел алфавита соответственно.
Формальное рекурсивное определение структуры
Вейвлет дерево последовательности S[1 ,n] на алфавите [a .. b] ⊆ [1 .. σ] это сбалансированное бинарное дерево b − a + 1 листьев такое что
если a = b просто лист "a"
иначе дерево имеет корень представляющий всю последовательность в виде битовой карты v_root определенной следующим образом
если S[i] не больше (a + b)/2 то v_root[i] = 0, иначе v_root[i] = 1
Определим S0[1 , n0] как подраздел S[1 ,n] состоящую из символов c > (a + b)/2 Тогда левая ветвь v_root это вейвлет дерево S0[1 , n0] на алфавите [a..(a + b)/2] и правая ветвь это в-дерево для S1[1, n1] на алфавите [1+(a + b)/2..b]

Можно заметить, что дерево будет lg(σ) высоты и иметь σ-1 узлов. На каждом уровне дерева будет храниться n бит. То есть всего нужно хранить n*lg(σ) бит.


Вейвлет дерево предоставляет два основных метода доступа.
Access(S[i])
Проверяем v_root[i]
Если 0 то S[i] в левом разделе словаря и левой ветви дерева, иначе направо. Остается решить на какую позицию в бит-карте узла проецируется символ. Если мы оперируем, например, вторым 0 в бит-карте очевидно символ будет проецироваться на вторую позицию левой ветви. Третья единица на третью позицию правой ветви и так вниз рекурсивно. Количество 0 до позиции i в бит-карте B принято считать функцией rank0(B, i), единиц rank1(B, i). Функции rank() и select() базовые функции над бит-картами для компактных(succinct) структур данных. (Толковое объяснение функций с картинками можно посмотреть в уже упомянутом посте https://habr.com/ru/company/mailru/blog/479822/) Алгоритмы для этих функции хорошо проработаны и реализованы.
Обратная операция
Track(symbol, count) позволяет найти symbol в последовательности S[i] использованный count раз. Для реализации этого метода понадобится вторая базовая функция select0(j) возвращающая индекс j-го 0 в бит-карте (или select1(j)). Двигаемся от словаря вверх до корня применяя эту функцию. Нам нужно просто обратить предыдущий алгоритм и вместо rank() применять select(). Чтобы найти в последовательности //TODO

Следует отметить что вейвлет дерево совсем не обязательно должно быть сбалансированным. Зная что некоторые символы встречаются в последовательности чаще других мы очень можем применить кодирование Хаффмана при построении дерева. Это лишь изменит топологию, а алгоритмы и функции будут работать как и прежде. И мы сможем добиться дополнительного сжатия данных и коротких треков для высокочастотных символов словаря.

Рассмотрим применение вейвлет дерева для построения индекса полнотекстового поиска. Обычно для этой цели строят обратный индекс - массив ассоциирующий символы словаря с позициями вхождения в последовательность. Преимуществами в-дерева в таком амплуа можно считать 
-нет необходимости хранить саму исходную последовательность
-обратный индекс предоставляет только метод Track(symbol), а у в-дерева есть еще метод Access(i) предлагающий обратную операцию - поиск символа по прямому индексу за логарифмическое время.
То есть вейвлет дерево это сразу два индекса прямой и обратный в компактном представлении.
Такие достоинства могут быть востребованы, для хранения больших индексированных //TODO

LOUDS

== Huffman

из очереди а не из кучи

== Dictionary

Double array trie вместо associative array

Для быстрого поиска по индексу кроме rank() и select() нужен еще быстрый поиск по словарю, особенно если этот словарь большой. Типично применять для этого ассоциативный массив. Однако associative array очень общая структура с избыточными характеристиками. В текстовых системах эффективней trie, префиксное дерево, ключами которого являются строки а значениями числа. Кроме большей скорости и компактности по сравнению с ассоциативным массивом на хеш-функциях префиксное дерево еще предлагает специфические для текстовых систем методы - PrefixMatch() и PrefixPredict(), необходимые например для автоподсказок. Однако хранить дерево ссылками может быть неэффективным по сравнению с последовательными структурами. И способы сериализации префиксного дерева появились. Сначала triple array trie, которое потом было модифицировано до double array trie. Почитать теорию вопроса можно здесь https://linux.thai.net/~thep/datrie/, хорошо объяснен классический алгоритм. Но структура получилась довольно сложная в реализации. И вот пожалуйста - вариант double array trie пришедший не из академического мира, а из блога коммерческой японской компании. Хоть и несколько ограниченный но подкупающий элегантностью, лаконичностью и простотой реализации в коде. Очень succinct.

== Реализация на Go
Для начала очень обобщенно, а то Go ругают за отсутствие generic и object oriented. Вот generic вейвлет дерево, архитектура сверху.
//TODO code

В качестве рабочей лошадки для операций над бит-картами будем использовать math/bits из stdlib. Этого нам вполне хватит(в Go качественная stdlib и ее обычно хватает). В качестве собственно бит-карты применяем []uint64. В комментариях исходников math/bits упоминается "Bit Twiddling Hacks By Sean Eron Anderson seander@cs.stanford.edu". Это хороший материал и его мы тоже будем использовать.

type Bitmap interface {
	Rank1(uint) uint
	Rank0(uint) uint
	Select1(uint) uint
	Select0(uint) uint
	Get(uint) int8
}

type WTree interface {
	BitMap() Bitmap
	RChild() WTree
	LChild() WTree
	Parrent() WTree
	IsLeaf() bool
	IsHead() bool
	IsLChild() bool
}

func Access(wt WTree, pos uint) (WTree, uint) {
	var bit int8
	for !wt.IsLeaf() {
		bit = wt.BitMap().Get(pos)
		if bit == 0 {
			pos = wt.BitMap().Rank0(pos) - 1
			wt = wt.LChild()
		} else {
			pos = wt.BitMap().Rank1(pos) - 1
			wt = wt.RChild()
		}
	}
	return wt, pos
}

func Track(wt WTree, count uint, bit int8) (WTree, uint) {
	lch := bit == 0
	for {
		if lch {
			count = wt.BitMap().Select0(count)
		} else {
			count = wt.BitMap().Select1(count)
		}
		if wt.IsHead() {
			break
		}
		lch = wt.IsLChild()
		wt = wt.Parrent()
	}
	return wt, count
}

индекс Щелкино
298213 д. 102 кв. 25
